{"version":3,"file":"diff.js","sources":["../../src/schema/diff.ts"],"sourcesContent":["import _ from 'lodash/fp';\nimport type {\n  Schema,\n  Table,\n  SchemaDiff,\n  Index,\n  ForeignKey,\n  Column,\n  IndexDiff,\n  IndexesDiff,\n  ForeignKeyDiff,\n  ForeignKeysDiff,\n  ColumnDiff,\n  TableDiff,\n  ColumnsDiff,\n} from './types';\nimport type { Database } from '..';\n\ntype PersistedTable = {\n  name: string;\n  dependsOn?: Array<{ name: string }>;\n};\n\ntype TableDiffContext = {\n  previousTable?: Table;\n  databaseTable: Table;\n  userSchemaTable: Table;\n};\n\ntype SchemaDiffContext = {\n  previousSchema?: Schema;\n  databaseSchema: Schema;\n  userSchema: Schema;\n};\n\n// TODO: get that list dynamically instead\nconst RESERVED_TABLE_NAMES = [\n  'strapi_migrations',\n  'strapi_migrations_internal',\n  'strapi_database_schema',\n];\n\nconst statuses = {\n  CHANGED: 'CHANGED',\n  UNCHANGED: 'UNCHANGED',\n} as const;\n\n// NOTE:We could move the schema to use maps of tables & columns instead of arrays to make it easier to diff\n// => this will make the creation a bit more complicated (ordering, Object.values(tables | columns)) -> not a big pbl\n\nconst helpers = {\n  hasTable(schema: Schema, tableName: string) {\n    return schema.tables.findIndex((table) => table.name === tableName) !== -1;\n  },\n  findTable(schema: Schema, tableName: string) {\n    return schema.tables.find((table) => table.name === tableName);\n  },\n  hasColumn(table: Table, columnName: string) {\n    return table.columns.findIndex((column) => column.name === columnName) !== -1;\n  },\n  findColumn(table: Table, columnName: string) {\n    return table.columns.find((column) => column.name === columnName);\n  },\n\n  hasIndex(table: Table, columnName: string) {\n    return table.indexes.findIndex((column) => column.name === columnName) !== -1;\n  },\n  findIndex(table: Table, columnName: string) {\n    return table.indexes.find((column) => column.name === columnName);\n  },\n\n  hasForeignKey(table: Table, columnName: string) {\n    return table.foreignKeys.findIndex((column) => column.name === columnName) !== -1;\n  },\n  findForeignKey(table: Table, columnName: string) {\n    return table.foreignKeys.find((column) => column.name === columnName);\n  },\n};\n\nexport default (db: Database) => {\n  const hasChangedStatus = (diff: { status: 'CHANGED' | 'UNCHANGED' }) =>\n    diff.status === statuses.CHANGED;\n\n  /**\n   * Compares two indexes info\n   * @param {Object} oldIndex - index info read from DB\n   * @param {Object} index - newly generate index info\n   */\n  const diffIndexes = (oldIndex: Index, index: Index): IndexDiff => {\n    const changes: string[] = [];\n\n    // use xor to avoid differences in order\n    if (_.xor(oldIndex.columns, index.columns).length > 0) {\n      changes.push('columns');\n    }\n\n    if (oldIndex.type && index.type && _.toLower(oldIndex.type) !== _.toLower(index.type)) {\n      changes.push('type');\n    }\n\n    return {\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: index.name,\n        object: index,\n      },\n    };\n  };\n\n  /**\n   * Compares two foreign keys info\n   * @param {Object} oldForeignKey - foreignKey info read from DB\n   * @param {Object} foreignKey - newly generate foreignKey info\n   */\n  const diffForeignKeys = (oldForeignKey: ForeignKey, foreignKey: ForeignKey): ForeignKeyDiff => {\n    const changes: string[] = [];\n\n    if (_.difference(oldForeignKey.columns, foreignKey.columns).length > 0) {\n      changes.push('columns');\n    }\n\n    if (_.difference(oldForeignKey.referencedColumns, foreignKey.referencedColumns).length > 0) {\n      changes.push('referencedColumns');\n    }\n\n    if (oldForeignKey.referencedTable !== foreignKey.referencedTable) {\n      changes.push('referencedTable');\n    }\n\n    if (_.isNil(oldForeignKey.onDelete) || _.toUpper(oldForeignKey.onDelete) === 'NO ACTION') {\n      if (\n        !_.isNil(foreignKey.onDelete) &&\n        _.toUpper(oldForeignKey.onDelete ?? '') !== 'NO ACTION'\n      ) {\n        changes.push('onDelete');\n      }\n    } else if (_.toUpper(oldForeignKey.onDelete) !== _.toUpper(foreignKey.onDelete ?? '')) {\n      changes.push('onDelete');\n    }\n\n    if (_.isNil(oldForeignKey.onUpdate) || _.toUpper(oldForeignKey.onUpdate) === 'NO ACTION') {\n      if (\n        !_.isNil(foreignKey.onUpdate) &&\n        _.toUpper(oldForeignKey.onUpdate ?? '') !== 'NO ACTION'\n      ) {\n        changes.push('onUpdate');\n      }\n    } else if (_.toUpper(oldForeignKey.onUpdate) !== _.toUpper(foreignKey.onUpdate ?? '')) {\n      changes.push('onUpdate');\n    }\n\n    return {\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: foreignKey.name,\n        object: foreignKey,\n      },\n    };\n  };\n\n  const diffDefault = (oldColumn: Column, column: Column) => {\n    const oldDefaultTo = oldColumn.defaultTo;\n    const { defaultTo } = column;\n\n    if (oldDefaultTo === null || _.toLower(oldDefaultTo) === 'null') {\n      return _.isNil(defaultTo) || _.toLower(defaultTo) === 'null';\n    }\n\n    return (\n      _.toLower(oldDefaultTo) === _.toLower(column.defaultTo) ||\n      _.toLower(oldDefaultTo) === _.toLower(`'${column.defaultTo}'`)\n    );\n  };\n\n  /**\n   * Compares two columns info\n   * @param {Object} oldColumn - column info read from DB\n   * @param {Object} column - newly generate column info\n   */\n  const diffColumns = (oldColumn: Column, column: Column): ColumnDiff => {\n    const changes: string[] = [];\n\n    const isIgnoredType = ['increments'].includes(column.type);\n    const oldType = oldColumn.type;\n    const type = db.dialect.getSqlType(column.type);\n\n    if (oldType !== type && !isIgnoredType) {\n      changes.push('type');\n    }\n\n    // NOTE: compare args at some point and split them into specific properties instead\n\n    if (oldColumn.notNullable !== column.notNullable) {\n      changes.push('notNullable');\n    }\n\n    const hasSameDefault = diffDefault(oldColumn, column);\n    if (!hasSameDefault) {\n      changes.push('defaultTo');\n    }\n\n    if (oldColumn.unsigned !== column.unsigned && db.dialect.supportsUnsigned()) {\n      changes.push('unsigned');\n    }\n\n    return {\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: column.name,\n        object: column,\n      },\n    };\n  };\n\n  const diffTableColumns = (diffCtx: TableDiffContext): ColumnsDiff => {\n    const { databaseTable, userSchemaTable, previousTable } = diffCtx;\n\n    const addedColumns: Column[] = [];\n    const updatedColumns: ColumnDiff['diff'][] = [];\n    const unchangedColumns: Column[] = [];\n    const removedColumns: Column[] = [];\n\n    for (const userSchemaColumn of userSchemaTable.columns) {\n      const databaseColumn = helpers.findColumn(databaseTable, userSchemaColumn.name);\n\n      if (databaseColumn) {\n        const { status, diff } = diffColumns(databaseColumn, userSchemaColumn);\n\n        if (status === statuses.CHANGED) {\n          updatedColumns.push(diff);\n        } else {\n          unchangedColumns.push(databaseColumn);\n        }\n      } else {\n        addedColumns.push(userSchemaColumn);\n      }\n    }\n\n    for (const databaseColumn of databaseTable.columns) {\n      if (\n        !helpers.hasColumn(userSchemaTable, databaseColumn.name) &&\n        previousTable &&\n        helpers.hasColumn(previousTable, databaseColumn.name)\n      ) {\n        removedColumns.push(databaseColumn);\n      }\n    }\n\n    const hasChanged = [addedColumns, updatedColumns, removedColumns].some((arr) => arr.length > 0);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        added: addedColumns,\n        updated: updatedColumns,\n        unchanged: unchangedColumns,\n        removed: removedColumns,\n      },\n    };\n  };\n\n  const diffTableIndexes = (diffCtx: TableDiffContext): IndexesDiff => {\n    const { databaseTable, userSchemaTable, previousTable } = diffCtx;\n\n    const addedIndexes: Index[] = [];\n    const updatedIndexes: IndexDiff['diff'][] = [];\n    const unchangedIndexes: Index[] = [];\n    const removedIndexes: Index[] = [];\n\n    for (const userSchemaIndex of userSchemaTable.indexes) {\n      const databaseIndex = helpers.findIndex(databaseTable, userSchemaIndex.name);\n      if (databaseIndex) {\n        const { status, diff } = diffIndexes(databaseIndex, userSchemaIndex);\n\n        if (status === statuses.CHANGED) {\n          updatedIndexes.push(diff);\n        } else {\n          unchangedIndexes.push(databaseIndex);\n        }\n      } else {\n        addedIndexes.push(userSchemaIndex);\n      }\n    }\n\n    for (const databaseIndex of databaseTable.indexes) {\n      if (\n        !helpers.hasIndex(userSchemaTable, databaseIndex.name) &&\n        previousTable &&\n        helpers.hasIndex(previousTable, databaseIndex.name)\n      ) {\n        removedIndexes.push(databaseIndex);\n      }\n    }\n\n    const hasChanged = [addedIndexes, updatedIndexes, removedIndexes].some((arr) => arr.length > 0);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        added: addedIndexes,\n        updated: updatedIndexes,\n        unchanged: unchangedIndexes,\n        removed: removedIndexes,\n      },\n    };\n  };\n\n  const diffTableForeignKeys = (diffCtx: TableDiffContext): ForeignKeysDiff => {\n    const { databaseTable, userSchemaTable, previousTable } = diffCtx;\n\n    const addedForeignKeys: ForeignKey[] = [];\n    const updatedForeignKeys: ForeignKeyDiff['diff'][] = [];\n    const unchangedForeignKeys: ForeignKey[] = [];\n    const removedForeignKeys: ForeignKey[] = [];\n\n    if (!db.dialect.usesForeignKeys()) {\n      return {\n        status: statuses.UNCHANGED,\n        diff: {\n          added: addedForeignKeys,\n          updated: updatedForeignKeys,\n          unchanged: unchangedForeignKeys,\n          removed: removedForeignKeys,\n        },\n      };\n    }\n\n    for (const userSchemaForeignKeys of userSchemaTable.foreignKeys) {\n      const databaseForeignKeys = helpers.findForeignKey(databaseTable, userSchemaForeignKeys.name);\n      if (databaseForeignKeys) {\n        const { status, diff } = diffForeignKeys(databaseForeignKeys, userSchemaForeignKeys);\n\n        if (status === statuses.CHANGED) {\n          updatedForeignKeys.push(diff);\n        } else {\n          unchangedForeignKeys.push(databaseForeignKeys);\n        }\n      } else {\n        addedForeignKeys.push(userSchemaForeignKeys);\n      }\n    }\n\n    for (const databaseForeignKeys of databaseTable.foreignKeys) {\n      if (\n        !helpers.hasForeignKey(userSchemaTable, databaseForeignKeys.name) &&\n        previousTable &&\n        helpers.hasForeignKey(previousTable, databaseForeignKeys.name)\n      ) {\n        removedForeignKeys.push(databaseForeignKeys);\n      }\n    }\n\n    const hasChanged = [addedForeignKeys, updatedForeignKeys, removedForeignKeys].some(\n      (arr) => arr.length > 0\n    );\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        added: addedForeignKeys,\n        updated: updatedForeignKeys,\n        unchanged: unchangedForeignKeys,\n        removed: removedForeignKeys,\n      },\n    };\n  };\n\n  const diffTables = (diffCtx: TableDiffContext): TableDiff => {\n    const { databaseTable } = diffCtx;\n\n    const columnsDiff = diffTableColumns(diffCtx);\n    const indexesDiff = diffTableIndexes(diffCtx);\n    const foreignKeysDiff = diffTableForeignKeys(diffCtx);\n\n    const hasChanged = [columnsDiff, indexesDiff, foreignKeysDiff].some(hasChangedStatus);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: databaseTable.name,\n        indexes: indexesDiff.diff,\n        foreignKeys: foreignKeysDiff.diff,\n        columns: columnsDiff.diff,\n      },\n    };\n  };\n\n  const diffSchemas = async (schemaDiffCtx: SchemaDiffContext): Promise<SchemaDiff> => {\n    const { previousSchema, databaseSchema, userSchema } = schemaDiffCtx;\n\n    const addedTables: Table[] = [];\n    const updatedTables: TableDiff['diff'][] = [];\n    const unchangedTables: Table[] = [];\n    const removedTables: Table[] = [];\n\n    // for each table in the user schema, check if it already exists in the database schema\n    for (const userSchemaTable of userSchema.tables) {\n      const databaseTable = helpers.findTable(databaseSchema, userSchemaTable.name);\n      const previousTable =\n        previousSchema && helpers.findTable(previousSchema, userSchemaTable.name);\n\n      if (databaseTable) {\n        const { status, diff } = diffTables({\n          previousTable,\n          databaseTable,\n          userSchemaTable,\n        });\n\n        if (status === statuses.CHANGED) {\n          updatedTables.push(diff);\n        } else {\n          unchangedTables.push(databaseTable);\n        }\n      } else {\n        addedTables.push(userSchemaTable);\n      }\n    }\n\n    // maintain audit logs table from EE -> CE\n    const parsePersistedTable = (persistedTable: string | Table) => 